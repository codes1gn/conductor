// Fused Multiplication + Addition Operation
// Demonstrates fusion of elementwise operations for better performance
// Pattern: (x * y) + z -> single fused kernel

__co__ f32 [32, 64] fused_mul_add(f32 [32, 64] input1, f32 [32, 64] input2, f32 [32, 64] input3) {
  f32[input1.span(0), input1.span(1)] output;

  parallel p by 2 {
    with index = {m_tile, n_tile} in [4, 8] {
      foreach m_tile, n_tile {
        lhs_load = dma.copy.async input1.chunkat(p, m_tile, n_tile) => local;
        rhs_load = dma.copy.async input2.chunkat(p, m_tile, n_tile) => local;
        bias_load = dma.copy.async input3.chunkat(p, m_tile, n_tile) => local;
        wait lhs_load, rhs_load, bias_load;

        local f32 [lhs_load.span] l1_out;

        // Fused mul + add operation - no intermediate buffer needed
        foreach i in [l1_out.span] {
          l1_out.at(i) = lhs_load.data.at(i) * rhs_load.data.at(i) + bias_load.data.at(i);
        }

        dma.copy l1_out => output.chunkat(p, m_tile, n_tile);
      }
    }
  }

  return output;
}
