// REQUIRES: TARGET-GCUALL
// RUN: choreo -gs -t factor %s -o %s.factor.result && bash %s.factor.result --execute | FileCheck --match-full-lines %s && rm -f %s.factor.result
// RUN: choreo -gs -t topscc %s -o %s.topscc.result && bash %s.topscc.result --execute | FileCheck --match-full-lines %s && rm -f %s.topscc.result

#include "choreo.h"
#include <random>

/*
http://wiki.enflame.cn/display/AUS/indim3_split0_outdim3_split1_perm1302

Memory Hierarchy
  D2C linear copy
  C2C transpose
  C2D deslice

input_shape_d = {a1, a2, a3, b, c, d};
input_reshape_d = {a4, a5, b * c * d};
input_shape_c = {1, a5, b * c * d};  // indim=3 split=0
input_reshape_c = {a5, b, c, d};
output_shape_c = {b, d, a5, c};
output_reshape_c = {b * d, 1, a5 * c};  // outdim=3 split=1
output_reshape_d = {b * d, a4, a5 * c};
output_shape_d = {b, d, a1, a2, a3, c};
*/

//                    s32 [A1,A2,A3,B, C, D] input
__co__ auto transpose(s32 [8, 2, 3, 2, 4, 2] input) {
  s32[input.span[(3), (5), (0), (1), (2), (4)]] output;
          // s32[ B,   D,  A1,  A2,  A3,   C] output;
  // python3 1.py
  // a4 = 3, a5 = 16
  parallel p by 1 {
    with index = {a4, a5, b, c, d} in [3, 1, 1, 1, 1] {
      foreach index {
        input_shape_c = dma.copy.async input.span_as([3, 16, 16]).chunkat(a4, a5, b#c#d) => local;
        wait input_shape_c;
        local s32[2, 2, 16, 4] output_shape_c;
        dma.transp<1, 3, 0, 2> input_shape_c.span_as([16, 2, 4, 2]) => output_shape_c;
        out_store = dma.copy.async output_shape_c.span_as([4, 1, 64]) => output.span_as([4, 3, 64]).chunkat(b#d, a4, a5#c);
        wait out_store;
      }
    }
  }
  return output;
}

int main() { /// host program

  #define aa1 8
  #define aa2 2
  #define aa3 3
  #define bb  2
  #define cc  4
  #define dd  2

  std::mt19937 mt(std::random_device{}());

  choreo::s32 x[aa1][aa2][aa3][bb][cc][dd] = {0};
  std::vector<int> bounds = {aa1, aa2, aa3, bb, cc, dd};
  int i = 0;
  for (size_t a1 = 0; a1 < bounds[0]; ++a1)
    for (size_t a2 = 0; a2 < bounds[1]; ++a2)
      for (size_t a3 = 0; a3 < bounds[2]; ++a3)
        for (size_t b = 0; b < bounds[3]; ++b)
          for (size_t c = 0; c < bounds[4]; ++c)
            for (size_t d = 0; d < bounds[5]; ++d)
              x[a1][a2][a3][b][c][d] = mt() % 10;

  // abcde => cadbe
  auto res = transpose(choreo::make_spanview<6, choreo::s32>(
      (int *)x, {aa1, aa2, aa3, bb, cc, dd}));

  for (int j=0; j<6; j++)
    std::cout << "res.shape()[" << j << "] = " << res.shape()[j] << "\n";

  // verfication
  for (size_t a1 = 0; a1 < bounds[0]; ++a1)
    for (size_t a2 = 0; a2 < bounds[1]; ++a2)
      for (size_t a3 = 0; a3 < bounds[2]; ++a3)
        for (size_t b = 0; b < bounds[3]; ++b)
          for (size_t c = 0; c < bounds[4]; ++c)
            for (size_t d = 0; d < bounds[5]; ++d) {
              if (x[a1][a2][a3][b][c][d] != res[b][d][a1][a2][a3][c]) {
                std::cout << a1 << ", " << a2 << ", " << a3 << ", " << b << ", " << c
                          << ", " << d << "\n";
                std::cout << "\tx: " << x[a1][a2][a3][b][c][d]
                          << "\n\tres: " << res[b][d][a1][a2][a3][c] << "\n";
                choreo::choreo_assert(x[a1][a2][a3][b][c][d] == res[b][d][a1][a2][a3][c], "values are not equal.");
              }
            }

  std::cout << "Test Passed\n" << std::endl;
}

// CHECK: Test Passed
