// REQUIRES: TARGET-GCU300
// RUN: choreo -gs -t topscc %s -o %s.topscc.result && bash %s.topscc.result --execute | FileCheck --match-full-lines %s && rm -f %s.topscc.result
// RUN-DOCKER: choreo -st -t topscc %s -o %s.topscc.result && %s.topscc.result | FileCheck --match-full-lines %s && rm -f %s.topscc.result

__co__ auto identity_three_buffers(f32 [768] input) {
  f32 [input.span(0)] output;

  parallel p by 1 {
    with {i} in [12] { // even iterations
      fa = dma.copy.async input.chunkat(i) => local;
      fb = dma.copy.async input.chunkat(i + 1) => local;
      fc = dma.any;
      foreach i(2:) {
        fc = dma.copy.async input.chunkat(i) => local;
        wait fa;
        dma.copy fa.data => output.chunkat(i - 2);
        rotate(fa, fb, fc);  // left rotate fa<-fb, fb<-fc, fc<-fa
      }
      wait fa;
      dma.copy fa.data => output.chunkat(i(-2));
      wait fb;
      dma.copy fb.data => output.chunkat(i(-1));
    }
  }

  return output;
}

__co__ auto identity_four_buffers(f32 [1024] input) {
  f32 [input.span(0)] output;

  parallel p by 1 {
    with {i} in [16] { // even iterations
      fa = dma.copy.async input.chunkat(i) => local;
      fb = dma.copy.async input.chunkat(i + 1) => local;
      fc = dma.copy.async input.chunkat(i + 2) => local;
      fd = dma.any;
      foreach i(3:) {
        fd = dma.copy.async input.chunkat(i) => local;
        wait fa;
        dma.copy fa.data => output.chunkat(i - 3);
        rotate(fa, fb, fc, fd);
      }
      wait fa;
      dma.copy fa.data => output.chunkat(i(-3));
      wait fb;
      dma.copy fb.data => output.chunkat(i(-2));
      wait fc;
      dma.copy fc.data => output.chunkat(i(-1));
    }
  }

  return output;
}


int main() { /// host program
  {
    choreo::f32 a[768];

    auto input_data = choreo::make_spanview<1, choreo::f32>((float*)a, {768});
    input_data.fill_random(-1.0, 1.0);

    auto res = identity_three_buffers(input_data);

    // verfication
    for (size_t i = 0; i < res.shape()[0]; ++i) {
      float ref = input_data[i];
      if (ref != res[i]) {
        std::cout << "i: " << i << "\n";
        std::cout << "res: " << res[i] << "\n";
        std::cout << "ref: " << ref << std::endl;
        choreo::choreo_assert(ref == res[i], "inconsistent result");
      }
    }
    std::cout << "Test 1 Passed" << std::endl;
  }

// CHECK: Test 1 Passed
  {
    choreo::f32 a[1024];

    auto input_data = choreo::make_spanview<1, choreo::f32>((float*)a, {1024});
    input_data.fill_random(-1.0, 1.0);

    auto res = identity_four_buffers(input_data);

    // verfication
    for (size_t i = 0; i < res.shape()[0]; ++i) {
      float ref = input_data[i];
      if (ref != res[i]) {
        // std::cout << "i: " << i << "\n";
        // std::cout << "res: " << res[i] << "\n";
        // std::cout << "ref: " << ref << std::endl;
        choreo::choreo_assert(ref == res[i], "inconsistent result");
      }
    }
    std::cout << "Test 2 Passed" << std::endl;
  }
// CHECK: Test 2 Passed
}
