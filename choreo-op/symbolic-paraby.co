// REQUIRES: TARGET-GCUALL
// RUN: choreo -gs -t factor %s 2>&1 | FileCheck --check-prefix=CHECKF %s
// RUN: choreo -gs -t topscc %s -o %s.topscc.result && bash %s.topscc.result --execute | FileCheck --match-full-lines %s && rm -f %s.topscc.result
#include "choreo.h"

__cok__ { 
__co_device__ extern "C" void kernel(int * a, int * b, int * c, int n) {
  for (int i = 0; i < n; ++i)
    c[i] = a[i] + b[i];
}
} 

__co__ s32 [N, 17, 128] ele_add(s32 [N, 17, 128] lhs, s32 [N, 17, 128] rhs, int PF) { 
  s32[lhs.span] output;

  parallel p by PF { 
    foreach {pf, x, y} in [N/PF, 17, 4] {
      lhs_load = dma.copy.async lhs.chunkat(p#pf, x, y) => local;
      rhs_load = dma.copy.async rhs.chunkat(p#pf, x, y) => local;
      wait lhs_load, rhs_load;

      local s32[lhs_load.span] l1_out;

      call kernel(lhs_load.data, rhs_load.data, l1_out, |lhs_load.span|);

      out_store = dma.copy.async l1_out => output.chunkat(p#pf, x, y);
      wait out_store;
    }
  }
  return output;
}

int main() { 
  choreo::s32 a[6][17][128] = {0};
  choreo::s32 b[6][17][128] = {0};
  
  auto a_data = choreo::make_spanview<3, choreo::s32>((int*)a, {6, 17, 128});
  auto b_data = choreo::make_spanview<3, choreo::s32>((int*)b, {6, 17, 128});
  a_data.fill_random(-10, 10);
  b_data.fill_random(-10, 10);

  int PF = 6;
  auto res = ele_add(a_data, b_data, PF);

 
  for (size_t i = 0; i < res.shape()[0]; ++i)
    for (size_t j = 0; j < res.shape()[1]; ++j)
      for (size_t k = 0; k < res.shape()[2]; ++k) {
        // std::cout << "i: " << i << ", j: " << j << ", k: " << k << "\n";
        // std::cout << "a: " << a[i][j][k] << ", b: " << b[i][j][k] << ", res: " << res[i][j][k] << "\n";
        choreo::choreo_assert(a[i][j][k] + b[i][j][k] == res[i][j][k], "values are not equal.");
      }

  std::cout << "Test Passed with PF: " << PF << "\n";

  PF = 2;
  auto res1 = ele_add(a_data, b_data, PF);

 
  for (size_t i = 0; i < res1.shape()[0]; ++i)
    for (size_t j = 0; j < res1.shape()[1]; ++j)
      for (size_t k = 0; k < res1.shape()[2]; ++k) {
        if (a[i][j][k] + b[i][j][k] != res[i][j][k]) {
          std::cout << "i: " << i << ", j: " << j << ", k: " << k << "\n";
          std::cout << "a: " << a[i][j][k] << ", b: " << b[i][j][k] << ", res1: " << res1[i][j][k] << "\n";
          choreo::choreo_assert(a[i][j][k] + b[i][j][k] == res[i][j][k], "values are not equal.");
        }
      }

  std::cout << "Test Passed with PF: " << PF << "\n";
}

// CHECK: Test Passed with PF: 6
// CHECK: Test Passed with PF: 2

// CHECKF: error: symbolic bound value is not supported for Factor backend yet.
