// REQUIRES: TARGET-GCU300
// RUN: choreo -gs -t factor %s -o %s.factor.result && bash %s.factor.result --execute | FileCheck --match-full-lines %s && rm -f %s.factor.result
// RUN: choreo -gs -t topscc %s -o %s.topscc.result && bash %s.topscc.result --execute | FileCheck --match-full-lines %s && rm -f %s.topscc.result

#include <chrono>

__cok__ {

__co_device__ extern "C" void relu_kernel(choreo::f16 * input, choreo::f16 * out) {
  constexpr int m = 128;
  constexpr int n = 256;
  for (int i = 0; i < m; ++i) {
    for (int j = 0; j < n; ++j) {
#if __GCU_ARCH__ == 210 && !defined(__TOPSCC__)
// workaround of f16 literals for old factor compiler
      ((uint16_t*)out)[i*n + j] = ((float)input[i*n + j] > 0.0f) ? ((uint16_t*)input)[i*n + j] : 0;
#else
      out[i*n + j] = choreo::f16_to_f32(input[i*n + j]) > 0.0f ? input[i*n + j] : choreo::f32_to_f16(0.0f);
#endif
    }
  }
}

} /// end of kernel decl


__co__ f16 [512, 1024] relu(f16 [512, 1024] input) { /// device program
  f16[input.span(0), input.span(1)] output; // use same shape as input

  parallel p by 2 {  // p is sip_index
    with index = {n_tile} in [1] {  // decl your tiled spans
      foreach n_tile {
        shared f16[input.span(0)/#p, input.span(1)/#n_tile] l2_out;
        input_load = dma.copy.async input.chunkat(p, n_tile) => shared;
        wait input_load;
        parallel q by 2 {
          with index = {m_tile_s, n_tile_s} in [2, 4] {
            local f16[l2_out.span(0)/#m_tile_s, l2_out.span(1)/#n_tile_s] l2_out_local;
            foreach n_tile_s {
              input_load_s = dma.copy input_load.data.chunkat(q, n_tile_s) => local;
              call relu_kernel(input_load_s.data, l2_out_local); // |span| calculate the total size of span.
              out_store_s = dma.copy l2_out_local => l2_out.chunkat(q, n_tile_s); // can use defined vars
            }
          }
        }
        out_store = dma.copy.async l2_out => output.chunkat(p, n_tile); // can use defined vars
        wait out_store;
      }
    }
  } // can use python styling
  return output;
}


int main() { /// host program
  choreo::f16 a[512][1024]; // unified abstraction in choreo type system, no need for C++ vectors/uint8_t, no factor Data/Mem types, we handles the bridge choreo::f16 b[512][512] = {0};

  auto input_data = choreo::make_spanview<2, choreo::f16>((choreo::f16*)a, {512, 1024});
  input_data.fill_random(-1.0f, 1.0f);

  auto start = std::chrono::high_resolution_clock::now();

  auto res = relu(input_data);

  auto end = std::chrono::high_resolution_clock::now();
  auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);

  std::cout << res.shape()[0] << std::endl;
  std::cout << res.shape()[1] << std::endl;

  // verfication
  for (size_t i = 0; i < res.shape()[0]; ++i)
    for (size_t j = 0; j < res.shape()[1]; ++j) {
        // std::cout << "i: " << i << ", j: " << j << "\n";
        // std::cout << "res: " << res[i][j].toFloat() << "\n";
        choreo::f16 ref = (float)input_data[i][j] > 0.0f ? input_data[i][j] : f32_to_f16(0.0f);

        // std::cout << "ref: " << ref.toFloat() << std::endl;
        choreo::choreo_assert(ref == res[i][j], "values are not equal.");
      }
  std::cout << "Test Passed\n" << std::endl;
  std::cout << "Function execution time: " << duration.count() << " microseconds" << std::endl;
}
// CHECK: Test Passed
