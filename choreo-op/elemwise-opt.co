// REQUIRES: TARGET-GCUALL
// RUN: choreo -gs -t topscc %s -o %s.topscc.result && bash %s.topscc.result --execute | FileCheck --match-full-lines %s && rm -f %s.topscc.result

#include <iostream>

__co__ auto ele_add(s32 [M] lhs, s32 [M] rhs) {
  s32 [lhs.span] output;

  // maximum parallelizations
  gpl = 2, bpl = 12;
  max_pl = gpl * bpl;

  // hardware limitations
  l1_limit = (1 << 20) + (1 << 19) - 512;
  l2_limit = 64 * (1 << 20);

  padding = 128 * bpl;

  // l1 contains lhs, rhs, output.
  l1_max_count = (l1_limit / |s32| / 3 / padding) * padding;
//  println!("l1_max_count: ", l1_max_count);

  // l2 contains only lhs, rhs. The output moved to global storage directly

  // l2 minimal element count which can fully feed max l1
  l2_mtp = l1_max_count * bpl;

//  l2_elem_count = (l2_limit / |s32| / 2 / l2_mtp) * l2_mtp;

  l2_elem_count = l2_mtp;

  if (M > (l2_elem_count * gpl)) {
    // in this scenario, it worth utilizing all the PEs
    __cpp__("auto start = std::chrono::high_resolution_clock::now();");

    parallel p by gpl, q by bpl {

      // iterate to handle most workload
      with x in [M / (l2_elem_count * #p)] foreach x(:1:) {

        inthreads (x # p * l2_elem_count + l2_elem_count <= M) {
          lfs = dma.copy.async lhs.subspan(l2_elem_count).at(x # p) => shared;
          rfs = dma.copy.async rhs.subspan(l2_elem_count).at(x # p) => shared;
          wait lfs, rfs;

          assert(|lfs.span| % padding == 0, "the data can not be divided evenly.");

          lfl = dma.copy.async lfs.chunkat(q) => local;
          rfl = dma.copy.async rfs.chunkat(q) => local;
          wait lfl, rfl;

          local s32 [lfl.span] l1_out;
          foreach i in [l1_out.span]
            l1_out.at(i) = lfl.data.at(i) + rfl.data.at(i);

          dma.copy l1_out => output.subspan(lfl.span).at(x # p # q);
        }

        // last iteration, handle the remainder count in a single p
        inthreads ((x # p * l2_elem_count + l2_elem_count > M) &&
            (x # p * l2_elem_count < M)) {
          rem_count = M % l2_elem_count;
          lfs = dma.copy.async lhs.modspan(l2_elem_count).at(x # p) => shared;
          rfs = dma.copy.async rhs.modspan(l2_elem_count).at(x # p) => shared;
          wait lfs, rfs;

          // decide the last count
          l1_min = 512;
          l1_count = (|lfs.span| / bpl + padding - 1) / padding * padding;
          last_count = (l1_min > l1_count) ? l1_min : l1_count;

          inthreads ((q + 1) * last_count <= rem_count) {
            lfl = dma.copy.async lfs.subspan(last_count).at(q) => local;
            rfl = dma.copy.async rfs.subspan(last_count).at(q) => local;
            wait lfl, rfl;

            local s32 [lfl.span] l1_out;

            foreach i in [l1_out.span]
              l1_out.at(i) = lfl.data.at(i) + rfl.data.at(i);

            dma.copy l1_out => output.modspan(l2_elem_count).at(x # p).subspan(last_count).at(q);
          }

          // last bunch
          inthreads ((q * last_count < rem_count) && ((q + 1) * last_count > rem_count)) {
            lfl = dma.copy.async lfs.modspan(last_count).at(q) => local;
            rfl = dma.copy.async rfs.modspan(last_count).at(q) => local;
            wait lfl, rfl;

            local s32 [lfl.span] l1_out;

            foreach i in [l1_out.span]
              l1_out.at(i) = lfl.data.at(i) + rfl.data.at(i);

            dma.copy l1_out => output.modspan(l2_elem_count).at(x # p).modspan(last_count).at(q);
          }
        }
      }
    }

    __cpp__("auto end = std::chrono::high_resolution_clock::now();\n");
    __cpp__("auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);\n");
    __cpp__(R"(std::cout << "time spend: " << duration.count() << "\n";)");
  }

  return output;
}

int main() {
  auto a = choreo::make_spandata<choreo::s32>(1 << 23);
  auto b = choreo::make_spandata<choreo::s32>(1 << 23);
  a.fill_random(-10, 10);
  b.fill_random(-10, 10);

  auto res = ele_add(a.view(), b.view());

  // verfication
  for (size_t i = 0; i < res.shape()[0]; ++i)
    choreo::choreo_assert(a[i] + b[i] == res[i], ("values[" + std::to_string(i) + "] are not equal.").c_str());

  std::cout << "Test Passed\n" << std::endl;
}

// CHECK: Test Passed
