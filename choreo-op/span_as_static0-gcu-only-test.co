// REQUIRES: TARGET-GCUALL
// RUN: choreo -gs -t factor %s -o %s.factor.result && bash %s.factor.result --execute | FileCheck --match-full-lines %s && rm -f %.factor.result
// RUN: choreo -gs -t topscc %s -o %s.topscc.result && bash %s.topscc.result --execute | FileCheck --match-full-lines %s && rm -f %s.topscc.result
// RUN-DOCKER: choreo -st -t topscc %s -o %s.topscc.result && %s.topscc.result | FileCheck --match-full-lines %s && rm -f %.topscc.result

#include "choreo.h"
#include <random>

/*
http://wiki.enflame.cn/display/AUS/indim5_split13_outdim5_split03_perm102

Memory Hierarchy
  D2C slice [1, 3]
  C2C transpose [1, 0, 2]
  C2D deslice [0, 3]

input_shape_d = {a, b, c, d, e, f};
input_reshape_d = {a * b, c, d, e, f};
input_shape_c = {a * b, 1, d, 1, f};
input_reshape_c = {a * b, d, f};
output_shape_c = {d, a * b, f};
output_reshape_c = {1, d, a, 1, b * f};
output_reshape_d = {c, d, a, e, b * f};
output_shape_d = {c, d, a, e, b, f};

*/

//                    s32 [A, B, C, D, E, F] input
__co__ auto transpose(s32 [4, 2, 4, 8, 2, 4] input) {

  s32[input.span[(2), (3), (0), (4), (1), (5)]] output;
           // s32[C,   D,   A,   E,   B,   F] output;

  parallel p by 1 {
    with index = {a, b, c, d, e, f} in input.span[1, 1, (2), 1, (4), 1] {
      foreach index {
        input_shape_c = dma.copy.async input.span_as([8, 4, 8, 2, 4]).chunkat(a#b, c, d, e, f) => local;
        wait input_shape_c;
        local s32[8, 8, 4] output_shape_c;
        // [a*b, d, f] => [d, a*b, f]
        dma.transp<1, 0, 2> input_shape_c.span_as([8, 8, 4]) => output_shape_c;
        // deslice on the first dim of 5-dim span on Topscc is wrong ?!
        // need to merge d and a
        // out_store = dma.copy.async output_shape_c.span_as([1, 8, 4, 1, 8]) => output.span_as([4, 8, 4, 2, 8]).chunkat(c, d, a, e, b#f);
        out_store = dma.copy.async output_shape_c.span_as([1, 32, 1, 8]) => output.span_as([4, 32, 2, 8]).chunkat(c, d#a, e, b#f);
        wait out_store;
      }
    }
  }
  return output;
}

int main() { /// host program

  #define aa 4
  #define bb 2
  #define cc 4
  #define dd 8
  #define ee 2
  #define ff 4

  std::mt19937 mt(std::random_device{}());

  choreo::s32 x[aa][bb][cc][dd][ee][ff] = {0};
  std::vector<int> bounds = {aa, bb, cc, dd, ee, ff};
  int i = 0;
  for (size_t a = 0; a < bounds[0]; ++a)
    for (size_t b = 0; b < bounds[1]; ++b)
      for (size_t c = 0; c < bounds[2]; ++c)
        for (size_t d = 0; d < bounds[3]; ++d)
          for (size_t e = 0; e < bounds[4]; ++e)
            for (size_t f = 0; f < bounds[5]; ++f) {
              // x[a][b][c][d][e] = i++;
              x[a][b][c][d][e][f] = mt() % 10;
            }

  // abcde => cadbe
  auto res = transpose(choreo::make_spanview<6, choreo::s32>((int*)x, {aa, bb, cc, dd, ee, ff}));

  for (int j=0; j<6; j++) {
    std::cout << "res.shape()[" << j << "] = " << res.shape()[j] << "\n";
  }

  // verification
  for (size_t a = 0; a < bounds[0]; ++a)
    for (size_t b = 0; b < bounds[1]; ++b)
      for (size_t c = 0; c < bounds[2]; ++c)
        for (size_t d = 0; d < bounds[3]; ++d)
          for (size_t e = 0; e < bounds[4]; ++e)
            for (size_t f = 0; f < bounds[5]; ++f) {
              auto vcpu = x[a][b][c][d][e][f];
              auto vgcu = res[c][d][a][e][b][f];
              if (vgcu != vcpu) {
                std::cout << a << ", " << b << ", " << c << ", " << d << ", " << e
                          << ", " << f << "\n";
                std::cout << "\tx: " << vcpu << "\n\tres: " << vgcu << "\n";
                choreo::choreo_assert(vcpu == vgcu, "output of gcu is wrong.");
              }
            }

  std::cout << "Test Passed\n" << std::endl;
}

// CHECK: Test Passed
