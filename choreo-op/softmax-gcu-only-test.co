// REQUIRES: TARGET-GCUALL
// RUN: choreo -gs -t factor %s -o %s.factor.result && bash %s.factor.result --execute | FileCheck --match-full-lines %s && rm -f %s.factor.result
// RUN: choreo -gs -t topscc %s -o %s.topscc.result && bash %s.topscc.result --execute | FileCheck --match-full-lines %s && rm -f %s.topscc.result
// RUN-DOCKER: choreo -st -t topscc %s -o %s.topscc.result && %s.topscc.result | FileCheck --match-full-lines %s && rm -f %s.topscc.result

#include "choreo.h"
#include <algorithm>
#include <cmath>
#include <iostream>
#include <vector>

__cok__ {
  // Kernel function: performs Softmax computation
__co_device__  extern "C" void kernel(float *input, float *output, int m, int n) {
    for (int i = 0; i < m; ++i) {
      float max_val = input[i * n];
      // Find the maximum value in the current row (to avoid numerical overflow)
      for (int j = 0; j < n; ++j)
        max_val = (max_val > input[i * n + j]) ? max_val : input[i * n + j];

      float sum = 0.0f;
      // Compute the exp of each element and accumulate it in sum
      for (int j = 0; j < n; ++j) {
        output[i * n + j] = expf(input[i * n + j] - max_val);
        sum += output[i * n + j];
      }

      // Normalize each element by dividing it by sum
      for (int j = 0; j < n; ++j)
        output[i * n + j] /= sum;
    }
  }
}
// Top-level function: Tile-based parallel softmax
__co__ auto softmax(f32[256, 512] input) {
  f32[input.span(0), input.span(1)] output;

  parallel p by 1 {
    with index = {m_tile, n_tile} in[256 / 64, 1] { // Define tile size
      foreach
        m_tile {
          local f32[64, 512] local_output;

          // Use DMA to load tile data into local memory
          local_input = dma.copy input.chunkat(m_tile, n_tile) => local;

          // Call the softmax kernel function
          call kernel(local_input.data, local_output, 64, 512);

          // Copy the result back to global memory
          dma.copy local_output => output.chunkat(m_tile, n_tile);
        }
    }
  }
  return output;
}
extern "C" void cpu_softmax(choreo::f32 *input, choreo::f32 *output, int m,
                            int n) {
  for (int i = 0; i < m; ++i) {
    float max_val = input[i * n];
    // Find the maximum value in the current row (to avoid numerical overflow)
    for (int j = 0; j < n; ++j)
      max_val = (max_val > input[i * n + j]) ? max_val : input[i * n + j];

    float sum = 0.0f;
    // Compute the exp of each element and accumulate it in sum
    for (int j = 0; j < n; ++j) {
      output[i * n + j] = exp(input[i * n + j] - max_val);
      sum += output[i * n + j];
    }

    // Normalize each element by dividing it by sum
    for (int j = 0; j < n; ++j)
      output[i * n + j] /= sum;
  }
}

// Main function: test softmax implementation
int main() {
  choreo::f32 input[256][512] = {0};
  std::fill_n(&input[0][0], sizeof(input) / sizeof(input[0][0]), 1.0f);

  auto input_data =
      choreo::make_spanview<2, choreo::f32>((float *)input, {256, 512});

  auto result = softmax(input_data);
  choreo::f32 result_cpu[256][512];

  // Perform softmax on the CPU
  cpu_softmax((choreo::f32 *)input, (choreo::f32 *)result_cpu, 256, 512);

  // Validation: Compare results between CPU and device
  bool match = true;

#if 1
  for (int i = 0; i < 256; ++i) {
    for (int j = 0; j < 512; ++j) {
      if (std::abs(result[i][j] - result_cpu[i][j]) > 1e-6) {
        std::cout << "Mismatch at [" << i << "][" << j
                  << "] - Device: " << result[i][j]
                  << ", CPU: " << result_cpu[i][j] << std::endl;
        match = false;
      }
    }
  }
#endif
  if (match) {
    std::cout << "Softmax Test Passed\n" << std::endl;
  } else {
    std::cout << "Softmax Test Failed\n" << std::endl;
  }
}
// CHECK: Softmax Test Passed
