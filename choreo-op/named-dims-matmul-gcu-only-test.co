// REQUIRES: TARGET-GCUALL DYNAMIC-SHAPE
// RUN: choreo -gs -t factor %s -o %s.factor.result && bash %s.factor.result --execute | FileCheck --match-full-lines %s && rm -f %s.factor.result
// RUN: choreo -gs -t topscc %s -o %s.topscc.result && bash %s.topscc.result --execute | FileCheck --match-full-lines %s && rm -f %s.topscc.result
// RUN-DOCKER: choreo -st -t topscc %s -o %s.topscc.result && %s.topscc.result | FileCheck --match-full-lines %s && rm -f %s.topscc.result
#include "choreo.h"

// extern "C" void kernel(int * lhs, int * rhs, int * out, int m, int k, int n) {
__cok__ { /// kernel program
__co_device__ extern "C" void kernel(int * lhs, int * rhs, int * out) {
  int m = 4;
  int k = 512;
  int n = 64;
  for (int i = 0; i < m; ++i)
    for (int j = 0; j < n; ++j)
      for (int z = 0; z < k; ++z)
        out[i*n + j] += lhs[i*k+z]*rhs[z*n+j];
}
} /// end of kernel decl

__co__ auto matmul_named_dims(s32 [M, K] lhs, s32 [K, N] rhs) {
  s32[lhs.span(0), rhs.span(1)] output;

  int m = 4;
  int n = 64;
  int k = 512;

  parallel p by 1 {
    with tilings = {m_tile, k_tile, n_tile} in [M/m, K/k, N/n] {  // decl your tiled spans
      foreach m_tile, n_tile {
        local s32 [m, n] l1_out {0};
        foreach k_tile {
          lhs_load = dma.copy lhs.chunkat(m_tile, k_tile) => local;
          rhs_load = dma.copy rhs.chunkat(k_tile, n_tile) => local;

          call kernel(lhs_load.data, rhs_load.data, l1_out);
          dma.copy l1_out => output.chunkat(m_tile, n_tile);
        }
      }
    }
  } // can use python styling
  return output;
}

int main() { /// host program
  choreo::s32 a[256][512] = {0};
  choreo::s32 b[512][512] = {0};
  auto lhs_data = choreo::make_spanview<2, choreo::s32>((int*)a, {256, 512});
  auto rhs_data = choreo::make_spanview<2, choreo::s32>((int*)b, {512, 512});
  lhs_data.fill_random(-10, 10);
  rhs_data.fill_random(-10, 10);
  
  auto res = matmul_named_dims(lhs_data, rhs_data);

  std::cout << res.shape()[0] << std::endl;
  std::cout << res.shape()[1] << std::endl;

  // verfication
  for (size_t i = 0; i < res.shape()[0]; ++i)
    for (size_t j = 0; j < res.shape()[1]; ++j) {
      int ref = 0;
      for (size_t k = 0; k < lhs_data.shape()[1]; ++k)
        ref += a[i][k]*b[k][j];
      if ( ref != res[i][j]) {
        // std::cout << "i: " << i << ", j: " << j << "\n";
        // std::cout << "res: " << res[i][j] << "\n";
        // std::cout << "ref: " << ref << std::endl;
        choreo::choreo_assert(ref == res[i][j], "values are not equal.");
      }
    }

  std::cout << "Test Passed\n" << std::endl;
}

// CHECK: Test Passed
